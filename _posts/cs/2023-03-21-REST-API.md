---
layout: single
title: "REST API"
categories: cs
tag: [cs, rest-api]
toc: true
toc_sticky: true
---

<br/>

# API?

클라이언트와 서버는 서로 직접적으로 호출하기보다는, **Application Programming Interface (API)**라 불리는 중간자 역할의 인터페이스를 사용한다.

<br/>

# REST API?

**Representational State Transfer**의 약자로 해석하면 원하는 리소스를 현재 상태에 걸맞은 형태로 전송하는 것이다.
**REST API**는 HTTP를 잘 사용하기 위해 **REST 아키텍처 스타일을 모두 준수한 API**이다.

<br/>

# REST 아키텍처 스타일

## Client - Server

- API를 통해 정보를 교환하는 주체는, 클라이언트와 서버 구조를 가져야한다.
- 클라이언트와 서버를 분리하여 서로 의존하지 않는 구조를 가져야한다.

## Stateless

- 무상태성(서로의 상태를 기억하지 않는다.)
- 클라이언트에서 서버로의 요청에는 그 요청을 이해하는데 필요한 모든 정보가 포함되어 있어야한다.
- 요청과 응답이 들어올 때 마다, 상대가 누구인지 파악할 수 있어야한다.

## Cache

- 요청에 대한 응답 내의 데이터에 캐시 가능여부가 명시되어 있어야한다.
- cache-control 헤더를 통해 명시 가능

## Uniform Interface

- 전체 시스템을 파악할 수 있는 인터페이스를 제공해야 한다.
- 전체적인 시스템 아키텍처를 간단하고 잘 파악할 수 있도록 약속된 인터페이스를 제공해야 한다.
- 가장 지켜지기 힘든 제약 조건이다. **\*밑에 상세 내용 확인**

## Laryered System

- 클라이언트는 서버에 직접 연결되었는지, 중간 서버를 통해 연결되었는지 알 수 없어야 한다.

## Code-On-Demand (Optional)

- Server 에서 보낸 코드를 Client에서 실행할 수 있어야함을 의미한다.
- 필요에 따라, 지켜도되고, 지키지않아도 REST에는 문제가 없다,
  <br/> <br/> <br/>

# Uniform Interface

## 1. 자원에 대한 식별 - dentification of resources

- 접근하고자 하는 자원을 명시하고, 그 자원을 식별할 수 있어야한다,

| 요구사항       | 잘목된 예시        | rest를 지킨 예시 |
| -------------- | ------------------ | ---------------- |
| 회원 목록 조회 | /read-member-list  | /members         |
| 회원 조회      | /read-member-by-id | /members/{id}    |
| 회원 등록      | /create-member     | /members         |
| 회원 수정      | /update-member     | /members{id}     |
| 회원 삭제      | /delete-member     | /members{id}     |

- 위와 같은 요구사항에 대한 자원은 회원뿐이다.
- 회원을 조회, 등록, 수정, 삭제 명령이 자원을 의미하지도 않으며, 식별할 수 있는 식별자 값도 아니다.
  따라서 **URI에 제어하고자 하는 자원에 대해 명시하고, 그 객체를 식별할 수있는 변하지 않는 식별자{id}를 URI를 통해 식별할 수 있도록 해야 한다.**

## 2. 표현을 통한 자원에 대한 조작 - Manipulation of resources through representations

- HTTP 메서드(표현)을 통해 HTTP 메세지에 해당 리소스에 대해 어떤 조작을 하는지 명시해야한다.

## 3. 자기 서술적 메세지 - Self-descriptive messages

- 메세지를 읽는 모든 주체들이, 메세지의 모든 요소는 메시지만 보고 그 의미를 파악할 수 있어야한다.

## 4. HATEOAS - Hypermedia as the engine of application state

- 하이퍼 미디어를 통한 앱 상태 변경 인터페이스를 제공해야한다.(현재 상태에서 어떤 페이지로 이동가능한지 보여야한다.)

<br/>

# REST API 설계 가이드

**1. 리소스에 대한 행위는 HTTP Method(POST, GET, PUT, DELETE)로 표현해야 한다.**

**2. URI 마지막 문자에 /를 사용하지 않는다.**

**3. URI에 \_ 대신 - 을 사용한다. 또한 영어 대문자보다는 소문자를 사용한다.**

**4. 관계를 나타내기 위해 엔드포인트를 중첩해 사용한다.**

- 엔드포인트끼리 연결되는 상황에선 이해하기 쉽도록 중첩해 사용한다.
- /(슬래시)는 계층 관계를 나타낼때 사용한다.
- 블로그 플랫폼의 경우 여러 게시물이 각기 다른 사용자들에 의해 작성된다.
  - **엔드포인트는 `http://mysite.com/posts/author`** 와 같이 사용한다.
- 게시물들은 각자 댓글들을 가지고 있기에 댓글을 조회할 수 있다.
  - **엔드 포인트는`https://mysite.com/posts/postId/comments`**와 같이 사용한다.
- **3단계 이상 중첩하면 가독성이 떨어지기 때문에 너무 많이 중첩하지 않는 것이 좋다.**<br/><br/>

**5. 복수 명사를 사용한다.**

- `https://mysite.com/post/123` 같은 엔드포인트가 있다면, `POST` 요청으로 게시물을 생성하거나, `PUT`, `PATCH` 요청을 통해 갱신하는게 가능하다.
- **사용자는 다른 게시물들이 있음을 알아채기 힘들 수 있어 복수 명사를 사용한다.** 따라서 `https://mysite.com/posts/123와` 같은 엔드포인트가 되어야 한다.<br/><br/>

**6. 엔드포인트에서는 동사 대신 명사를 사용한다.**

- 엔드포인트 주소에 명사를 사용하여 각 엔드포인트들이 무슨 일을 하는지 명시해야 한다.
  - `HTTP` 메소드들이 이미 `GET(READ)` `POST(CREATE)` `PUT(UPDATE)` `DELETE(DELETE)` 라는 동작을 동사의 형태로 나타내기 때문이다.
    - **잘못된 엔드포인트 주소:** `https://mysite.com/getPosts` 혹은 `https://mysite.com/createPosts`
    - **정상적인 엔드포인트 주소:** `https://mysite.com/posts`
- **따라서 HTTP 메소드로 엔드포인트가 무슨 일을 할지 정하도록 하자.**<br/><br/>

**7. 에러 핸들링을 위해 상태 코드를 사용한다.**

- API 요청에 대해 응답할 때는 항상 HTTP 상태 코드를 포함해야 한다. 그래야 사용자가 요청이 성공했는지, 실패했는지 상태를 확인 할 수 있다.<br/><br/>

**6. 데이터를 받을 때 필터링, 정렬, 페이지네이션을 사용한다.**

- API의 데이터베이스의 규모가 큰 경우에는 데이터베이스에서 데이터를 받아올 때 느려질 수가 있다.
- 필터링, 정렬, 페이지네이션을 통해 필요한 데이터만 걸러내어 요청에 대한 부담을 줄일수 있다.
  - 필터링된 엔드포인트를 보면 https://mysite.com/posts?tags=javascript 와 같이 사용할 수있다.<br/><br/>

**7. URI에 파일의 확장자(예를들어 .json , .JPGE)를 포함 시키지 않는다.**

<br/>

# 정리

- 클라이언트와 서버의 요청 및 응답을 위해 API를 사용한다
- API를 설계할때 REST 아키텍처를 사용하여 정해진 규격에 맞게 설계한다.
- REST API 설계시 주의점
  - 리소스에 대한 행위는 HTTP Method를 사용한다.
  - URI 마지막 문자에 /를 사용하지 않는다.
  - URI에 \_ 대신 - 을 사용한다. 또한 영어 대문자보다는 소문자를 사용한다.
  - 관계를 나타내기 위해 엔드포인트를 중첩해 사용한다.
  - 복수 명사를 사용한다.
  - 엔드포인트에서는 동사 대신 명사를 사용한다.
  - 에러 핸들링을 위해 상태 코드를 사용한다.
  - 데이터를 받을 때 필터링, 정렬, 페이지네이션을 사용한다.
  - URI에 파일의 확장자를 포함 시키지 않는다.
